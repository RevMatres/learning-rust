
// '->'        means the thing returns something
//             the thing after the arrow is the return type (like in java functions the word before the name delcaration)
// Result      signifies that an operation might fail, in which case in place of the result you'll get an Err (=error duh)
//             if it doesn't fail you'll get an Ok
// enum <...>  a thing that could be any of the things in <...>
// 
// And generally: this is the game logic, so no rendering and not even an execution loop.
// Some external thing has to loop and call the update functions on the game_state structure, so the thing is always updated manually.
// The game then provides a 'render buffer' which is a Buffer, that contains a color, where there is a block, and nothing where there isn't and it's a copy of the game_state's internal game buffer.
// I use two buffers cause then the renderer can render even though an update is happening simoultaneously.
// The rest should be basically self-explanatory... I hope ¯\_(ツ)_/¯


// this is a buffer that contains a two dimensional array (of rows and columns in rows) on the heap
pub struct Buffer { 
	Board: Box< [[Option<Color>; COLUMN_NUMBER]; ROW_NUMBER] >;
}

impl Buffer {
	create(width, height) -> Buffer {
		return Buffer { Board: new Box< [[None(); width]; height] > }
	}
}





pub enum Event < General, Move_down, Move_left, Move_right, Rotate, Render >

enum Orientation < Normal, Quarter, Half, ThreeQuarter >
enum Direction < Left, Right, Down >

pub struct Color = (f32, f32, f32);

struct Block { // a single block
	x
	y
}

struct Blocks = [Block; 4];


pub enum Shape < SHAPE_NAME(Color) >
shape_to_blocks(Shape) -> Blocks {
	match Shape {
		... => return ...
	}
}
choose_shape() -> Shape {

	// generate a random number, that fits in the range of possible shapes
	// make a decision and return that

}



struct game_block { // a full game block, made of its parts

	// note: if a block has -1, -1 as position, the renderer shouldn't render it
	x;
	y;

	blocks = Blocks;

	color: Color;

	orientation: Orientation;

}

impl game_block {

	create(shape: Shape, x, y) -> game_block {
		let color = shape(color)

		let blocks = shape_to_blocks(shape)

		return game_block {
			x, y,
			color,
			blocks,
			orientation = Normal,
		}
	}

	runner_mut<F>(&mut self, f: F) where F: Fn(&mut Self) {
		f(self);
	}

	runner<F>(&self, f: F) where F: Fn(&Self) {
		f(self);
	}

	dry_rotate(&self) -> [[i32; 2]; 4] {
		// magic
	}

	dry_move(&self, dir: Direction) -> [[i32; 2]; 4] {
		match dir {
			Left  => { return [ self.x - 1, self.y ] },
			Right => { return [ self.x + 1, self.y ] },
			Down  => { return [ self.x, self.y + 1 ] },
		}
	}

	rotate_for_real(&mut self) {
		// rotate but mutate
	}

	move_for_real(&mut self, dir: Direction) {
		match dir {
			Left  => { self.x -= 1 },
			Right => { self.x += 1 },
			Down  => { self.y += 1 },
		}
	}

	get_actual_positions(&self) -> Blocks {
		return self.blocks.iter().map(|b| return [b.x+self.x, b.y+self.y]).collect();
	}

}





struct game_state {

	score;

	time_stamp: Time; // time of last down motion
	update_interval;

	block_queue: Shape;
	active_block: game_block;

	board_buffer: Buffer;

	render_buffer: arc<rwlock<Buffer>>.write(); // the render_buffer is read-write-locked so nothing on the outside can accidentally edit it

}

impl game_state {

	pub create( buffer_width, buffer_height, game_speed, render_buffer_reference ) -> game_state {

		return game_state {
			score = 0;

			time_stamp = new Time::stamp(or whatever);
			update_interval = game_speed;

			block_queue = choose_shape();
			active_block = game_block::create(choose_shape(), START_X, START_Y),

			board_buffer = Buffer::create(buffer_width, buffer_height),

			render_buffer = render_buffer_reference,
		}
		
	}


	pub get_score(&self) -> i32 {
		return self.score;
	}

	pub get_next_block(&self) -> Shape {
		return self.block_queue;
	}
		


	/* Update functions */
	// Err result means GAME_OVER


	pub update(&self, e: Event ) -> Result {
		match e {
			General    => self.general_update()?,
			Move_down  => self.event_update(Move_down)?,
			Move_left  => self.event_update(Move_left)?,
			Move_right => self.event_update(Move_right)?,
			Rotate     => self.event_update(Rotate)?,
			Render     => self.update_render_buffer()?,
		}
	}

	update_render_buffer(&mut self) -> Result {

		// options:
		// - just plain copy the board_buffer and replace the render buffer with that
		//    - possibly use the write trait to write the stuff as bytes?
		// - compute the delta between the two and only exchange those values (as you go along)

		return Ok

	}

	general_update(&mut self) -> Result {
		
		if self.game_over() { return Err(GAME_OVER) }

		delta_time = (new Time) - self.time_stamp;
		if delta_time > self.update_interval { self.move(Down) }
		self.time_stamp = new Time;

		self.check_rows();

		return Ok
	}

	event_update(&mut self, e: Event) -> Result {

		match e {
			Rotate     => self.rotate(),
			Move_down  => self.move(Down),
			Move_left  => self.move(Left),
			Move_right => self.move(Right),
		}

		return Ok
	}

	check_rows(&mut self) {

		let full_removed = self.board_buffer.iter().filter(/*NOT FILLED*/).collect();

		let lines_removed = self.board_buffer.len() - full_removed.len();
		/* score based on removed lines */

		// empty board_buffer

		board_buffer = full_removed

		// iterate over the rows, find the ones, that are completely filled
		// filled = row.iter().fold() -> returns true if filled

		// if found a filled one
		//   update the score
		//   move the above rows down by copying the values, fill in blanks or sth like that

		// continue

	}



	/* Event Action Functions */

	// check if action() can be executed by first dry running it using dry_run()
	// specifically: check if action() would affect spaces on the board, that
	// are already occupied, by using dry_run() to first produce the coordinates
	// active_block would have after applying action()
	do_if_empty<F, G>(dry:F, action:G) -> Result where
		F: Fn(&Self)
		G: Fn(&mut Self) {
			temp_coods = self.active_block.runner(dry);
			empty? = !self.is_occupied(temp_coods);

			if empty? {
				self.active_block.runner_mut(action());
				return Ok;
			} else {
				return Err
			}
	}

	rotate() {
		success = self.do_if_empty(|a| a.dry_rotate(), |b| b.rotate());
		// I'm not handling success, cause if the rotation fails, just nothing should happen.
	}

	move(dir: Direction) {
		success = self.do_if_empty(|a| a.dry_move(dir), |b| b.move(dir));
		if let Err = success { // if moving was unsuccessfull, a collision happened, so merge the block and update the score
			self.merge_block();
		}
	}

	is_occupied(blocks: Blocks) -> boolean {
		for block in blocks.iter() {
			if self.block_is_in_buffer(block) { return true }
		}

		return false
	}

	block_is_in_buffer(b: block) -> boolean {
		if let Some(color) = Buffer[b.y][b.x] { return true }
		return false
	}




	/* What to do when a collision happens */

	merge_block() {
		for block in self.active_block.get_actual_positions.iter() {
			self.board_buffer[block.x, block.y] = Some(self.active_block.color);
		}
	}
