enum Direction

struct Buffer {
	// I want this heap allocated so it doesn't auto copy!
	Box<[ [ Option<game_block>; GAME_COLUMNS ]; GAME_ROWS ]>;
}

pub tuple Color = (r, g, b);

struct game_block {

	x
	y
	color: Color
	orientation

}

impl game_block {

	// return array of position values
	dry_rotate -> [[x,y],[...]]

	rotate()

}

impl Copy for game_block { // or whatever the explicit duplicate trait is }


struct game_state {

	time_stamp = ?

	block_queue: new game_block;



	board_buffer = new Buffer();

	init_board_buffer(&mut board_buffer); // inits board buffer to None()s



	active_block: new game_block;


	render_buffer_reference = render_buffer.write(); // render_buffer is in an rwLock, this is the only write lock holder
							 // this has to be wrapped in an arc

}


impl game_state {

	create(width, height, Arc<RwLock<Buffer>>)

	update() -> Result<Ok('s fine) | Err(game_over)> {
		/* update the active_block and board_buffer */

		// check for game over condition
		// if game over: return Err(game_over)

		// compute delta time
		if time for motion
			move(Down)

		return OK('s fine)
	}

	update(enum Event) {
		/* update the active_block and board_buffer */

		if Event<Rotate> then rotate(Direction)
		if Event<Move<Direction>> then move(Direction)

	}

	rotate(Direction) {
		temp_coordinates = active_block.dry_rotate(Direction)

		// check whether any of the points would already exist
		for each in temp_coordinates
			is_in_buffer?
	}

	move(Direction) {
		check collision in direction
		if collision
			merge_block()
			active_block = block_queue
			block_queue = new block
		else if !collision
			update active_block's coordinates
	}

	update_render_buffer() {
		// decide whether to just copy the board_buffer or to actually compute a delta and update smartly...
		// or: empty the box and actually replace the data inside the buffer â†’ Write trait?
	}

	detect_collision(&active_block, &board_buffer) -> Boolean {
		is_in_buffer(active_block's coordinates + appropriate values)
		[... repeat for all actual blocks in active_block]
	}

	// checks whether provided x and y coordinates already exist in a game buffer
	is_in_buffer(takes coordinates to check) -> Boolean

	merge_block(&mut active_block, &mut board_buffer) {
		// copy each single_block into the board_buffer
	}

	get_score()
	get_queue()

}
